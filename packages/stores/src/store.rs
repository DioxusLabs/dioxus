use crate::{
    scope::SelectorScope,
    subscriptions::{StoreSubscriptions, TinyVec},
};
use dioxus_core::{
    use_hook, AttributeValue, DynamicNode, IntoAttributeValue, IntoDynNode, Subscribers, SuperInto,
};
use dioxus_signals::{
    read_impls, write_impls, BorrowError, BorrowMutError, CopyValue, Global,
    InitializeFromFunction, MappedMutSignal, ReadSignal, Readable, ReadableExt, ReadableRef,
    Storage, UnsyncStorage, Writable, WritableExt, WritableRef, WriteSignal,
};
use std::marker::PhantomData;

/// A type alias for a read-only store.
pub type ReadStore<T> = Store<T, ReadSignal<T>>;

/// Stores are a reactive type built for nested data structures. Each store will lazily create signals
/// for each field/member of the data structure as needed.
///
/// By default stores act a lot like [`dioxus_signals::Signal`]s, but they provide more granular
/// subscriptions without requiring nested signals. You should derive [`Store`](dioxus_stores_macro::Store) on your data
/// structures to generate selectors that let you scope the store to a specific part of your data.
///
/// # Example
///
/// ```rust, no_run
/// use dioxus::prelude::*;
/// use dioxus_stores::*;
///
/// fn main() {
///     dioxus::launch(app);
/// }
///
/// // Deriving the store trait provides methods to scope the store to specific parts of your data structure.
/// // The `Store` macro generates a `count` and `children` method for the `CounterTree` struct.
/// #[derive(Store, Default)]
/// struct CounterTree {
///     count: i32,
///     children: Vec<CounterTree>,
/// }
///
/// fn app() -> Element {
///     let value = use_store(Default::default);
///
///     rsx! {
///         Tree {
///             value
///         }
///     }
/// }
///
/// #[component]
/// fn Tree(value: Store<CounterTree>) -> Element {
///     // Calling the generated `count` method returns a new store that can only
///     // read and write the count field
///     let mut count = value.count();
///     let mut children = value.children();
///     rsx! {
///         button {
///             // Incrementing the count will only rerun parts of the app that have read the count field
///             onclick: move |_| count += 1,
///             "Increment"
///         }
///         button {
///             // Stores are aware of data structures like `Vec` and `Hashmap`. When we push an item to the vec
///             // it will only rerun the parts of the app that depend on the length of the vec
///             onclick: move |_| children.push(Default::default()),
///             "Push child"
///         }
///         ul {
///             // Iterating over the children gives us stores scoped to each child.
///             for value in children.iter() {
///                 li {
///                     Tree { value }
///                 }
///             }
///         }
///     }
/// }
/// ```
pub struct Store<T: ?Sized, W = WriteSignal<T>> {
    selector: SelectorScope<W>,
    _phantom: PhantomData<Box<T>>,
}

impl<T: 'static, S: Storage<T>> Store<T, CopyValue<T, S>> {
    /// Creates a new `Store` that might be sync. This allocates memory in the current scope, so this should only be called
    /// inside of an initialization closure like the closure passed to [`use_hook`].
    #[track_caller]
    pub fn new_maybe_sync(value: T) -> Self {
        let store = StoreSubscriptions::new();
        let value = CopyValue::new_maybe_sync(value);

        let path = TinyVec::new();
        let selector = SelectorScope::new(path, store, value);
        selector.into()
    }
}

impl<T: 'static> Store<T> {
    /// Creates a new `Store`. This allocates memory in the current scope, so this should only be called
    /// inside of an initialization closure like the closure passed to [`use_hook`].
    #[track_caller]
    pub fn new(value: T) -> Self {
        let store = StoreSubscriptions::new();
        let value = CopyValue::new_maybe_sync(value);
        let value = value.into();

        let path = TinyVec::new();
        let selector = SelectorScope::new(path, store, value);
        selector.into()
    }
}

impl<T: ?Sized, W> Store<T, W> {
    /// Get the underlying selector for this store. The selector provides low level access to the lazy tracking system
    /// of the store. This can be useful to create selectors for custom data structures in libraries. For most applications
    /// the selectors generated by the [`Store`](dioxus_stores_macro::Store) macro provide all the functionality you need.
    pub fn selector(&self) -> &SelectorScope<W> {
        &self.selector
    }

    /// Convert the store into the underlying selector
    pub fn into_selector(self) -> SelectorScope<W> {
        self.selector
    }
}

impl<T: ?Sized, W> From<SelectorScope<W>> for Store<T, W> {
    fn from(selector: SelectorScope<W>) -> Self {
        Self {
            selector,
            _phantom: PhantomData,
        }
    }
}

impl<T: ?Sized, W> PartialEq for Store<T, W>
where
    W: PartialEq,
{
    fn eq(&self, other: &Self) -> bool {
        self.selector == other.selector
    }
}
impl<T: ?Sized, W> Clone for Store<T, W>
where
    W: Clone,
{
    fn clone(&self) -> Self {
        Self {
            selector: self.selector.clone(),
            _phantom: ::std::marker::PhantomData,
        }
    }
}
impl<T: ?Sized, W> Copy for Store<T, W> where W: Copy {}

impl<__F, __FMut, T: ?Sized, W> ::std::convert::From<Store<T, MappedMutSignal<T, W, __F, __FMut>>>
    for Store<T, WriteSignal<T>>
where
    W: Writable<Storage = UnsyncStorage> + 'static,
    __F: Fn(&W::Target) -> &T + 'static,
    __FMut: Fn(&mut W::Target) -> &mut T + 'static,
    T: 'static,
{
    fn from(value: Store<T, MappedMutSignal<T, W, __F, __FMut>>) -> Self {
        Store {
            selector: value.selector.map_writer(::std::convert::Into::into),
            _phantom: ::std::marker::PhantomData,
        }
    }
}
impl<__F, __FMut, T: ?Sized, W> ::std::convert::From<Store<T, MappedMutSignal<T, W, __F, __FMut>>>
    for Store<T, ReadSignal<T>>
where
    W: Writable<Storage = UnsyncStorage> + 'static,
    __F: Fn(&W::Target) -> &T + 'static,
    __FMut: Fn(&mut W::Target) -> &mut T + 'static,
    T: 'static,
{
    fn from(value: Store<T, MappedMutSignal<T, W, __F, __FMut>>) -> Self {
        Store {
            selector: value.selector.map_writer(::std::convert::Into::into),
            _phantom: ::std::marker::PhantomData,
        }
    }
}

#[doc(hidden)]
pub struct SuperIntoReadSignalMarker;
impl<T, W> SuperInto<ReadSignal<T>, SuperIntoReadSignalMarker> for Store<T, W>
where
    T: 'static,
    W: Readable<Target = T, Storage = UnsyncStorage> + 'static,
{
    fn super_into(self) -> ReadSignal<T> {
        ReadSignal::new(self)
    }
}

#[doc(hidden)]
pub struct SuperIntoWriteSignalMarker;
impl<T, W> SuperInto<WriteSignal<T>, SuperIntoWriteSignalMarker> for Store<T, W>
where
    T: 'static,
    W: Writable<Target = T, Storage = UnsyncStorage> + 'static,
{
    fn super_into(self) -> WriteSignal<T> {
        WriteSignal::new(self)
    }
}

impl<T: ?Sized, W> Readable for Store<T, W>
where
    W: Readable<Target = T>,
    T: 'static,
{
    type Storage = W::Storage;
    type Target = T;
    fn try_read_unchecked(&self) -> Result<ReadableRef<'static, Self>, BorrowError> {
        self.selector.try_read_unchecked()
    }
    fn try_peek_unchecked(&self) -> Result<ReadableRef<'static, Self>, BorrowError> {
        self.selector.try_peek_unchecked()
    }
    fn subscribers(&self) -> Option<Subscribers> {
        self.selector.subscribers()
    }
}
impl<T: ?Sized, W> Writable for Store<T, W>
where
    W: Writable<Target = T>,
    T: 'static,
{
    type WriteMetadata = W::WriteMetadata;
    fn try_write_unchecked(&self) -> Result<WritableRef<'static, Self>, BorrowMutError> {
        self.selector.try_write_unchecked()
    }
}
impl<T, W> IntoAttributeValue for Store<T, W>
where
    Self: Readable<Target = T>,
    T: ::std::clone::Clone + IntoAttributeValue + 'static,
{
    fn into_value(self) -> AttributeValue {
        ReadableExt::cloned(&self).into_value()
    }
}
impl<T, W> IntoDynNode for Store<T, W>
where
    Self: Readable<Target = T>,
    T: ::std::clone::Clone + IntoDynNode + 'static,
{
    fn into_dyn_node(self) -> DynamicNode {
        ReadableExt::cloned(&self).into_dyn_node()
    }
}
impl<T, W> ::std::ops::Deref for Store<T, W>
where
    Self: Readable<Target = T> + 'static,
    T: ::std::clone::Clone + 'static,
{
    type Target = dyn Fn() -> T;
    fn deref(&self) -> &Self::Target {
        unsafe { ReadableExt::deref_impl(self) }
    }
}

read_impls!(Store<T, W> where W: Readable<Target = T>);
write_impls!(Store<T, W> where W: Writable<Target = T>);

/// Create a new [`Store`]. Stores are a reactive type built for nested data structures.
///
///
/// By default stores act a lot like [`dioxus_signals::Signal`]s, but they provide more granular
/// subscriptions without requiring nested signals. You should derive [`Store`](dioxus_stores_macro::Store) on your data
/// structures to generate selectors that let you scope the store to a specific part of your data structure.
///
/// # Example
///
/// ```rust, no_run
/// use dioxus::prelude::*;
/// use dioxus_stores::*;
///
/// fn main() {
///     dioxus::launch(app);
/// }
///
/// // Deriving the store trait provides methods to scope the store to specific parts of your data structure.
/// // The `Store` macro generates a `count` and `children` method for `Store<CounterTree>`.
/// #[derive(Store, Default)]
/// struct CounterTree {
///     count: i32,
///     children: Vec<CounterTree>,
/// }
///
/// fn app() -> Element {
///     let value = use_store(Default::default);
///
///     rsx! {
///         Tree {
///             value
///         }
///     }
/// }
///
/// #[component]
/// fn Tree(value: Store<CounterTree>) -> Element {
///     // Calling the generated `count` method returns a new store that can only
///     // read and write the count field
///     let mut count = value.count();
///     let mut children = value.children();
///     rsx! {
///         button {
///             // Incrementing the count will only rerun parts of the app that have read the count field
///             onclick: move |_| count += 1,
///             "Increment"
///         }
///         button {
///             // Stores are aware of data structures like `Vec` and `Hashmap`. When we push an item to the vec
///             // it will only rerun the parts of the app that depend on the length of the vec
///             onclick: move |_| children.push(Default::default()),
///             "Push child"
///         }
///         ul {
///             // Iterating over the children gives us stores scoped to each child.
///             for value in children.iter() {
///                 li {
///                     Tree { value }
///                 }
///             }
///         }
///     }
/// }
/// ```
pub fn use_store<T: 'static>(init: impl FnOnce() -> T) -> Store<T> {
    use_hook(move || Store::new(init()))
}

/// A type alias for global stores
///
/// # Example
/// ```rust, no_run
/// use dioxus::prelude::*;
/// use dioxus_stores::*;
///
/// #[derive(Store)]
/// struct Counter {
///    count: i32,
/// }
///
/// static COUNTER: GlobalStore<Counter> = Global::new(|| Counter { count: 0 });
///
/// fn app() -> Element {
///     let mut count = COUNTER.resolve().count();
///
///     rsx! {
///         button {
///             onclick: move |_| count += 1,
///             "{count}"
///         }
///     }
/// }
/// ```
pub type GlobalStore<T> = Global<Store<T>, T>;

impl<T: 'static> InitializeFromFunction<T> for Store<T> {
    fn initialize_from_function(f: fn() -> T) -> Self {
        Store::new(f())
    }
}
