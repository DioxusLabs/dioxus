use std::collections::HashSet;
use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let events_dir = manifest_dir.join("src/events");

    let mut event_methods = Vec::new();
    let mut seen = HashSet::new();

    let mut entries: Vec<_> = fs::read_dir(&events_dir)
        .expect("read events dir")
        .filter_map(|entry| entry.ok())
        .map(|entry| entry.path())
        .filter(|path| path.extension().and_then(|ext| ext.to_str()) == Some("rs"))
        .collect();
    entries.sort();

    for path in &entries {
        println!("cargo:rerun-if-changed={}", path.display());
        let content = fs::read_to_string(path).expect("read event file");
        for (event_name, data_type) in parse_events(&content) {
            if seen.insert(event_name.clone()) {
                event_methods.push((event_name, data_type));
            }
        }
    }

    let mut output = String::new();
    output.push_str("// @generated by dioxus-html/build.rs\n");
    output.push_str("impl ElementBuilder {\n");
    for (event_name, data_type) in event_methods {
        output.push_str(&format!(
            "    pub fn {name}(self, handler: impl FnMut(dioxus_core::Event<crate::events::{data}>) + 'static) -> Self {{\n",
            name = event_name,
            data = data_type
        ));
        output.push_str("        #[allow(deprecated)]\n");
        output.push_str(&format!(
            "        let attr = crate::events::{name}(handler);\n",
            name = event_name
        ));
        output.push_str(
            "        self.push_attribute(attr.name, attr.namespace, attr.value, attr.volatile)\n",
        );
        output.push_str("    }\n\n");
    }
    output.push_str("}\n");

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    fs::write(out_dir.join("builder_events.rs"), output).expect("write builder_events.rs");
}

fn parse_events(source: &str) -> Vec<(String, String)> {
    let mut results = Vec::new();
    let mut lines = source.lines().peekable();

    while let Some(line) = lines.next() {
        if !line.contains("impl_event!") {
            continue;
        }

        let mut block_lines = Vec::new();
        for next in lines.by_ref() {
            let trimmed = next.trim();
            if trimmed.starts_with("///") {
                continue;
            }
            if !trimmed.is_empty() {
                block_lines.push(trimmed.to_string());
            }
            if trimmed.starts_with("}") || trimmed.starts_with("]") {
                break;
            }
        }

        if let Some((data_type, events)) = parse_event_block(&block_lines) {
            for event in events {
                results.push((event, data_type.clone()));
            }
        }
    }

    results
}

fn parse_event_block(lines: &[String]) -> Option<(String, Vec<String>)> {
    let mut data_type = None;
    let mut events = Vec::new();
    let mut in_events = false;

    for line in lines {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("//") || trimmed.starts_with("#") {
            continue;
        }

        if data_type.is_none() {
            if let Some(semi) = trimmed.find(';') {
                let ty = trimmed[..semi].trim();
                if !ty.is_empty() {
                    data_type = Some(ty.to_string());
                    in_events = true;
                }
            }
            continue;
        }

        if !in_events {
            continue;
        }

        if trimmed.starts_with("}") || trimmed.starts_with("]") {
            break;
        }

        if let Some(name) = parse_event_name(trimmed) {
            events.push(name);
        }
    }

    data_type.map(|ty| (ty, events))
}

fn parse_event_name(line: &str) -> Option<String> {
    let trimmed = line.trim();
    if trimmed.is_empty() || trimmed.starts_with("//") || trimmed.starts_with("#") {
        return None;
    }

    let mut end = 0;
    for (idx, ch) in trimmed.char_indices() {
        if ch.is_alphanumeric() || ch == '_' || ch == '#' {
            end = idx + ch.len_utf8();
        } else {
            break;
        }
    }

    if end == 0 {
        return None;
    }

    let name = trimmed[..end].trim();
    Some(name.trim_start_matches("r#").to_string())
}
