<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Subsecond</title>
        <script>
            /**
             * @typedef {object} JumpTable
             * @property {string} lib - The URL of the WebAssembly module to fetch and instantiate.
             * @property {{[key: number]: number}} map - The exports of the WebAssembly module to patch.
             */
            /**
             * Loads a WebAssembly module from a given URL, instantiates it, and applies a patch
             * to the provided base object using the module's exported functions.
             *
             * @param {JumpTable} jump - The jump table to be patched with the WebAssembly module's exports.
             * @param {WebAssembly.Exports} base - The base object to be patched with the WebAssembly module's exports.
             * @returns {void} This function does not return a value.
             */
            function loadAndPatch(jump, base) {
                fetch(jump.lib)
                    .then((response) => response.arrayBuffer())
                    .then((bytes) => {
                        const ifunc_length = base.__indirect_function_table.length;
                        base.__indirect_function_table.grow(2000);
                        let imports = {
                            env: {
                                __indirect_function_table: base.__indirect_function_table,
                                __stack_pointer: base.__stack_pointer,
                                __tls_base: base.__tls_base,
                                memory: base.memory,
                                __IFUNC_OFFSET: new WebAssembly.Global({value: "i32", mutable: false }, ifunc_length + 1),
                            },
                        };
                        for (const key of Object.keys(base)) {
                            imports.env[key] = base[key];
                        }
                        return WebAssembly.instantiate(bytes, imports);
                    })
                    // function pointers correlate directly to exports.table.get(pointer!)
                    //
                    // object.keys(patch_exports) -> gives us names of functions
                    //
                    // we end up making a map of original ptr to... what??
                    //
                    // if we load the new module into the same table then its pointers should be valid too?
                    //
                    // the jump table can continue to be a map of ptr -> ptr
                    //
                    // but we somehow need to get the exports as pointers too
                    //
                    // the exported functions return a "pointer object" whose `name` field *is the pointer* (but as a string)
                    //
                    // so in theory we....
                    //  object.values(patch.exports) => [name, ptr]
                    //  source.exports[name].name => ptr
                    //
                    // call patchJumpTable({ptr: ptr})
                    .then((patch) => {
                        window.patch = patch;

                        // We're going to match up export to export and then ifunc entry to ifunc entry
                        // We're going to build a map of old -> new ifunc entries
                        const patchExports = patch.instance.exports;

                        let nameToNativeMain = Object.fromEntries(
                            Object.keys(wasmExports).map((key) => [key, wasmExports[key].name]).filter(([key, name]) => name !== undefined)
                        );

                        let nameToNativePatch = Object.fromEntries(
                            Object.keys(patchExports).map((key) => [key, patchExports[key].name]).filter(([key, name]) => name !== undefined)
                        );

                        let nativeToIndex = Object.fromEntries(
                            [...Array(wasmExports.__indirect_function_table.length).keys()].map((i) => {
                                let entry = wasmExports.__indirect_function_table.get(i);
                                if (entry === null) {
                                    return ["abc", 0];
                                }
                                if (entry.name === undefined) {
                                    return ["abc", 0];
                                }
                                return [entry.name, i];
                            })
                        );

                        let jumpTable = Object.fromEntries(
                            Object.entries(nameToNativePatch)
                                .map(([fnName, nativeName]) => {
                                    let oldIndex = nativeToIndex[nameToNativeMain[fnName]];
                                    let newIndex = nativeToIndex[nativeName];
                                    return [fnName, [oldIndex, newIndex]];
                                })
                                .filter(([name, [oldIndex, newIndex]]) =>
                                    oldIndex !== undefined && newIndex !== undefined
                                )
                        );

                        window.jumpTable = jumpTable;

                        let app_name = Object.keys(patchExports).find(key => key.includes("subsecond_harness11dioxus_demo3app17"));
                        let patchEntry = jumpTable[app_name];
                        console.log("patchEntry", patchEntry, app_name);
                        base["__subsecond_wasm_patch"](patchEntry);
                    });
            }


            function main() {
                const socket = new WebSocket("ws://localhost:9393");

                socket.onmessage = (event) => {
                    try {
                        const jump = JSON.parse(event.data);
                        console.log("Received jump table:", jump);
                        if (window.wasmExports) {
                            jump.lib = jump.lib.split('/').pop();
                            console.log("Patching jump table with:", jump);
                            loadAndPatch(jump, window.wasmExports);
                        } else {
                            console.error("wasmExports is not initialized yet.");
                        }
                    } catch (error) {
                        console.error("Failed to process WebSocket message:", error);
                    }
                };

                socket.onopen = () => {
                    socket.send("123");
                    console.log("WebSocket connection established.")
                };
                socket.onerror = (error) => console.error("WebSocket error:", error);
                socket.onclose = () => console.log("WebSocket connection closed.");
            }

            window.loadAndPatch = loadAndPatch;
            main();
        </script>
        <script type="module">
            import init from "./main.js";
            init().then((wasmExports) => {
                window.wasmExports = wasmExports;
            });
        </script>
    </head>
    <body>
        <div id="main"></div>
    </body>
</html>
