<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Subsecond</title>
        <script>
            /**
             * @typedef {object} JumpTable
             * @property {string} lib - The URL of the WebAssembly module to fetch and instantiate.
             * @property {{[key: number]: number}} map - The exports of the WebAssembly module to patch.
             */
            /**
             * Loads a WebAssembly module from a given URL, instantiates it, and applies a patch
             * to the provided base object using the module's exported functions.
             *
             * @param {JumpTable} jump - The jump table to be patched with the WebAssembly module's exports.
             * @param {WebAssembly.Exports} base - The base object to be patched with the WebAssembly module's exports.
             * @returns {void} This function does not return a value.
             */
            function loadAndPatch(jump, base) {
                window.jump = jump;
                fetch(jump.lib)
                    .then((response) => response.arrayBuffer())
                    .then((bytes) => {
                        const pageSize = 64 * 1024;
                        const ifunc_length = base.__indirect_function_table.length;
                        const data_start = Math.ceil((base.memory.buffer.byteLength / pageSize) + 1 ) * pageSize;
                        base.memory.grow(20);
                        base.__indirect_function_table.grow(2000);

                        // move the jumptable "to" addresses by the ifunc length
                        for (let key of Object.keys(jump.map)) {
                            let entry = jump.map[key];
                            if (entry === undefined) {
                                continue;
                            }
                            jump.map[key] = entry + ifunc_length;
                        }


                        let imports = {
                            env: {
                                __memory_base: data_start,
                                __table_base: ifunc_length,
                                __indirect_function_table: base.__indirect_function_table,
                                __stack_pointer: base.__stack_pointer,
                                __tls_base: base.__tls_base,
                                memory: base.memory,
                            },
                        };
                        for (const key of Object.keys(base)) {
                            imports.env[key] = base[key];
                        }
                        return WebAssembly.instantiate(bytes, imports);
                    }).then((patch) => {
                        window.patch = patch;
                        window.jump = jump;
                        patch.instance.exports["__wasm_apply_data_relocs"]();
                        base["__subsecond_wasm_patch"](jump.map);
                    });
            }


            function main() {
                const socket = new WebSocket("ws://localhost:9393");

                socket.onmessage = (event) => {
                    try {
                        const jump = JSON.parse(event.data);
                        console.log("Received jump table:", jump);
                        if (window.wasmExports) {
                            jump.lib = jump.lib.split('/').pop();
                            console.log("Patching jump table with:", jump);
                            loadAndPatch(jump, window.wasmExports);
                        } else {
                            console.error("wasmExports is not initialized yet.");
                        }
                    } catch (error) {
                        console.error("Failed to process WebSocket message:", error);
                    }
                };

                socket.onopen = () => {
                    socket.send("0");
                    console.log("WebSocket connection established.")
                };
                socket.onerror = (error) => console.error("WebSocket error:", error);
                socket.onclose = () => console.log("WebSocket connection closed.");
            }

            window.loadAndPatch = loadAndPatch;
            main();
        </script>
        <script type="module">
            import init from "./main.js";
            init().then((wasmExports) => {
                window.wasmExports = wasmExports;
            });
        </script>
    </head>
    <body>
        <div id="main"></div>
    </body>
</html>
<!--

// function pointers correlate directly to exports.table.get(pointer!)
//
// object.keys(patch_exports) -> gives us names of functions
//
// we end up making a map of original ptr to... what??
//
// if we load the new module into the same table then its pointers should be valid too?
//
// the jump table can continue to be a map of ptr -> ptr
//
// but we somehow need to get the exports as pointers too
//
// the exported functions return a "pointer object" whose `name` field *is the pointer* (but as a string)
//
// so in theory we....
//  object.values(patch.exports) => [name, ptr]
//  source.exports[name].name => ptr
//
// call patchJumpTable({ptr: ptr})
.then((patch) => {
    window.patch = patch;
    window.jump = jump;

    console.log("jump ttable:", jump);
    base["__subsecond_wasm_patch"](jump.map);

    // // We're going to match up export to export and then ifunc entry to ifunc entry
    // // We're going to build a map of old -> new ifunc entries
    // const patchExports = patch.instance.exports;

    // let nameToNativeMain = Object.fromEntries(
    //     Object.keys(wasmExports).map((key) => [key, wasmExports[key].name]).filter(([key, name]) => name !== undefined)
    // );

    // let nameToNativePatch = Object.fromEntries(
    //     Object.keys(patchExports).map((key) => [key, patchExports[key].name]).filter(([key, name]) => name !== undefined)
    // );

    // let nativeToIndex = Object.fromEntries(
    //     [...Array(wasmExports.__indirect_function_table.length).keys()].map((i) => {
    //         let entry = wasmExports.__indirect_function_table.get(i);
    //         if (entry === null) {
    //             return ["__", 0];
    //         }
    //         if (entry.name === undefined) {
    //             return ["__", 0];
    //         }
    //         return [entry.name, i];
    //     })
    // );

    // let jumpTable = Object.fromEntries(
    //     Object.entries(nameToNativePatch)
    //         .map(([fnName, nativeName]) => {
    //             let oldIndex = nativeToIndex[nameToNativeMain[fnName]];
    //             let newIndex = nativeToIndex[nativeName];
    //             return [fnName, [oldIndex, newIndex]];
    //         })
    //         .filter(([name, [oldIndex, newIndex]]) =>
    //             oldIndex !== undefined && newIndex !== undefined
    //         )
    // );

    // let patchList = Object.keys(patchExports).flatMap((key) => {
    //     let entry = jumpTable[key];
    //     if (entry === undefined) {
    //         return [];
    //     }
    //     let a = entry[0];
    //     let b = entry[1];

    //     if (a === undefined || b === undefined) {
    //         return [];
    //     }

    //     return [a, b];
    // });

    // base["__subsecond_wasm_patch"](patchList);
}); -->
