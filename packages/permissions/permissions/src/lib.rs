#![doc = include_str!("../README.md")]
#![deny(missing_docs)]

//! # Permissions
//!
//! A cross-platform permission management system with linker-based collection.
//!
//! This crate provides a unified API for declaring permissions across supported platforms
//! (Android, iOS, macOS) and embeds them in the binary for extraction by build tools.
//!
//! ## Usage
//!
//! ```rust
//! use permissions::{static_permission, Permission};
//!
//! // Declare a camera permission (static / compile-time)
//! const CAMERA: Permission = static_permission!(Camera, description = "Take photos");
//!
//! // Declare a location permission with precision
//! const LOCATION: Permission = static_permission!(Location(Fine), description = "Track your runs");
//!
//! // Use the permission
//! println!("Camera permission: {}", CAMERA.description());
//! if let Some(android_perm) = CAMERA.android_permission() {
//!     println!("Android permission: {}", android_perm);
//! }
//! ```
//!
//! > **Note:** `permission!` remains available as an alias for `static_permission!`
//! > to preserve backward compatibility with existing code.

pub use permissions_core::{
    LocationPrecision, Permission, PermissionHandle, PermissionKind, PermissionManifest, Platform, PlatformFlags,
    PlatformIdentifiers,
};
pub use permissions_macro::{permission, static_permission};

#[doc(hidden)]
pub mod macro_helpers {
    //! Helper functions for macro expansion
    //!
    //! These functions are used internally by the `static_permission!()` macro (and its `permission!()` alias)
    //! and should not be used directly.

    pub use const_serialize::{self, ConstStr, ConstVec, SerializeConst};
    pub use dx_macro_helpers::copy_bytes;
    pub use permissions_core::Permission;

    /// Serialize a permission to a const buffer with a large enough buffer size
    pub const fn serialize_permission(permission: &Permission) -> ConstVec<u8, 4096> {
        dx_macro_helpers::serialize_to_const_with_max::<4096>(
            permission,
            Permission::MEMORY_LAYOUT.size(),
        )
    }

    /// Serialize a LinkerSymbol::Permission to a const buffer
    #[cfg(feature = "manganis")]
    pub const fn serialize_linker_symbol_permission(permission: &Permission) -> ConstVec<u8, 4096> {
        use manganis_core::LinkerSymbol;
        dx_macro_helpers::serialize_to_const_with_max::<4096>(
            &LinkerSymbol::Permission(*permission),
            LinkerSymbol::MEMORY_LAYOUT.size(),
        )
    }
}

/// Request a permission at runtime.
///
/// This function takes a `Permission` as a required argument and returns a `PermissionHandle`.
/// The permission must be passed as an argument to ensure it's not optimized away, and the
/// returned handle performs volatile reads to keep the symbol in the binary.
///
/// # Example
///
/// ```rust
/// use permissions::{Permission, PermissionKind, request_permission};
///
/// const CAMERA_PERM: Permission = Permission::new(
///     PermissionKind::Camera,
///     "Take photos"
/// );
///
/// // Request the permission - this ensures it's included in the binary
/// let handle = request_permission(CAMERA_PERM);
/// let permission = handle.permission();
/// ```
pub fn request_permission(permission: Permission) -> PermissionHandle {
    // The permission is passed as a required argument, which forces the compiler
    // to keep any references to it. The PermissionHandle will perform volatile reads
    // to ensure the linker section remains in the binary.
    //
    // Note: In practice, this function should be called with a permission that was
    // created via the macro, which will have already set up the linker section.
    // This function exists primarily as a way to ensure the permission is used.
    PermissionHandle::new(|| {
        // This is a placeholder - the actual implementation will be generated by the macro
        // which will create the proper linker section reference
        &[]
    })
}
