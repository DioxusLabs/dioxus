/// We use the readme as the frontpage of the docs.rs for most crates, but Crates.io and github render code blocks slightly different from docs.rs.
/// This CLI searches through the current directory for markdown files that have the `-docs-rs` suffix and transforms them to remove lines that start with `# ` in fenced rust code blocks.
///
/// # Usage
///
/// Run this command in the root of the workspace:
/// ```bash
/// cargo run --package crates-io-readme
/// ```
use anyhow::{Context, Result};
use pulldown_cmark::{CodeBlockKind, Event, Tag, TagEnd};
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

fn main() -> Result<()> {
    let current_dir = std::env::current_dir()?;
    // walk up looking for a git root
    let mut git_root = current_dir.as_path();
    while !git_root.join(".git").exists() {
        if let Some(parent) = git_root.parent() {
            git_root = parent;
        } else {
            break;
        }
    }
    let git_folder = git_root.join(".git");
    let gitignore_path = git_root.join(".gitignore");

    // Ignore files in the gitignore
    let (ignore, _) = ignore::gitignore::Gitignore::new(&gitignore_path);

    // Process all markdown files in the current directory
    for entry in WalkDir::new(&current_dir).into_iter().filter_entry(|e| {
        let path = e.path();
        let is_dir = path.is_dir();
        // Ignore files in the gitignore
        ignore.matched(path, is_dir).is_none() && !path.starts_with(&git_folder)
    }) {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("md") {
            let stem_name = path
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or_default();
            if let Some(base_name) = stem_name.strip_suffix("-docs-rs") {
                process_markdown_file(path, &path.with_file_name(base_name).with_extension("md"))?;
            }
        }
    }

    println!("✅ Transformation complete!");
    Ok(())
}

fn process_markdown_file(path: &Path, output_path: &Path) -> Result<()> {
    // Read the markdown file
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read file: {}", path.display()))?;

    let source_file_name = path
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or_default();

    // Transform the markdown content
    let mut output_writer = format!(
        "<!-- This file is autogenerated from {source_file_name}. Edit that file instead and rerun `cargo run --package crates-io-readme` before publishing -->\n"
    );
    transform_markdown_to(&content, &mut output_writer)?;

    // Write the transformed content to the output file
    fs::write(output_path, output_writer)
        .with_context(|| format!("Failed to write file: {}", output_path.display()))?;

    println!("  ✅ Transformed: {}", path.display());
    Ok(())
}

fn transform_markdown_to(content: &str, writer: impl std::fmt::Write) -> Result<()> {
    let parser = pulldown_cmark::Parser::new(content);
    let iterator = pulldown_cmark::TextMergeWithOffset::new(parser.into_offset_iter());

    let mut in_rust_block = false;
    let iterator = iterator.map(|(event, offset)| match &event {
        Event::Start(Tag::CodeBlock(info)) => {
            // docs.rs strips lines in rust blocks that start with `# `
            if let CodeBlockKind::Fenced(lang) = info {
                let is_rust =
                    lang.starts_with("rust") || lang.starts_with("rs") || lang.starts_with("rsx");
                in_rust_block = is_rust;
            }
            (event, Some(offset))
        }
        Event::End(TagEnd::CodeBlock) => {
            in_rust_block = false;
            (event, Some(offset))
        }
        Event::Text(text) if in_rust_block => {
            // Strip lines that start with `# `
            let stripped_text = text
                .lines()
                .filter(|line| !line.starts_with("# "))
                .collect::<Vec<_>>()
                .join("\n");
            (Event::Text(stripped_text.into()), None)
        }
        _ => (event, Some(offset)),
    });

    let options = pulldown_cmark_to_cmark::Options {
        code_block_token_count: 3,
        list_token: '-',
        emphasis_token: '_',
        ..Default::default()
    };
    pulldown_cmark_to_cmark::cmark_with_source_range_and_options(
        iterator, content, writer, options,
    )?;

    Ok(())
}
